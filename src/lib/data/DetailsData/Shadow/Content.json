{
	"block1": "<b>Contributions :</b><ul><li>Developed and maintained a tool to generate interactable flat 2D shadows from 3D models</li><li>Created the mechanic of light exclusion</li><li>Rigged and animated 2D skeletal meshes of enemy sprites</li><li>Worked on some puzzles</li></ul><p>The way the shadow script genrally works is it generates shadows of 3D models and place it in thescene, each shadow have a script that determines its size and position based on the distance to the light source and wall casted on.</p><b>For a basic flow of sequence :</b><ol><li>Assuming you have a 3D object to generate for, instantiate copy of object in front of sub camera.</li><li>Adjust translation and size to fit the camera lens</li><li>Snap a photo with background removed</li>\n\t<li>Save the picture as sprite and apply some settings to it</li>\n\t<li>Create an empty object and place a sprite rendere component on it</li>\n\t<li>\n\t\tAttach to the original 3D game object and adjust the size and positon of the spirite based on\n\t\tdistance to the main light source and main wall\n\t</li>\n</ol>",

	"block2": "<b>The main script for shadow generated is as follows :</b><p>This section is 'snapshot' phase referenced from a screenshot plugin, while this part maybe heavily referenced, the rest of the code are original. This code involves the screenshot actionand converting into a sprite.</p>",

	"block3": "<p>Then store the sprite in a specified folder, and apply texture settings with UNITY_EDITOR, shadow generation is only done once in the editor as this is a mobile game.</p><p>To change shadow shape in real-time we had a workaround that we did not have the chance to apply but, the idea is to generat multiple frames of the object at different angles then animate between them.</p>",

	"block4": "<b>Note</b> <p>The rest of the code can be found at the snippet link from the first snippet.</p><p>The idea for this way of generating shadows was conceived on week 2 of the project when it was approved by the lecturer, the rest of the time was spent on improving the tool and making it more user friendly.</p><p>It was somewhat of a cheese way that doesn't require real time shadow rendering which is a heavy task for mobile devices, but it was a fun experiment. The other reason for this method is normal 3D shadow has a complex shape, which makes it hard to build a 2D level.</p><p>Our method however snaps the objects in orthographic mode therefore generating flat sprites, allowing for easy level blocking.</p>",

	"block5": "<b>Shadow/Light exclusion</b><p>Another mechanic was planned and added for the second level, but the second level didn't make it to the final build but I'll be explaining it here. This mechanic is to negate shadows, making them passable, it can be enemies or obstacles.</p>",

	"block6": "<b>How it works</b><p>The script is a simple one, for context, the enemy has 3 different colliders. Any colliders that intersect with the 'light' will be disabled and enqued into a queue, once the collider is out of range, it will be reenabled based on sequence, hence the queue data structure</p><p>There is an Coroutine in this script that checks whether the light is still colliding with the collider through a custom function as the in-built unity one is catered for 3D collisions and doesn't work in our particular case. The coroutine would check every 0.5 seconds, if it is still colliding, add it to the back of the queue, else reenable the component.</p>",

	"block7": "<b>Custom bound functions</b><p>The following are just a slight rewrite to Unity's default bounds functions and removing the Z axis, the reason for this is because Unity's default bounds functions checks for Z value, which is not needed in our case.</p><p>Another notable issue is when calling the .bounds variable from a disabled collider component returns 0 no matter what, hence why there is a need to cahce the extent/bounds of collided components.<p>"
}
