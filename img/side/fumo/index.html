<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Fumo Engine: User Manual</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Fumo Engine
   </div>
   <div id="projectbrief">A funky engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">User Manual </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="mainpage"></a> <img src="https://imgur.com/yE7MuA3.png" alt="FumoEngine" class="inline"/> </p>
<h1><a class="anchor" id="autotoc_md0"></a>
Fumo Engine</h1>
<p>Welcome to the funky manual of Fumo Engine or Fumo for short. This manual will guide you through the process of using the engine to create scenes, custom components, use built-in components all the way to building a game!</p>
<h3><a class="anchor" id="autotoc_md1"></a>
Engine wide Controls</h3>
<p><code>[ Tab ]</code> to pause/unpause application. <br  />
 <code>[ Esc ]</code> to exit applicaiton.</p>
<h3><a class="anchor" id="autotoc_md2"></a>
Made By</h3>
<p>0133532 Lim Jun Jie</p>
<hr  />
<p><br  />
</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Table of Contents</h1>
<ol type="1">
<li><a class="el" href="index.html#introduction">Introduction</a></li>
<li><a class="el" href="index.html#creating-scenes">Creating Scenes</a></li>
<li><a class="el" href="index.html#custom-components">Custom Components</a></li>
<li><a class="el" href="index.html#tyingit">Tying scene and components</a></li>
<li><a class="el" href="index.html#core-game-engine-components">Core Game Engine Components</a><ul>
<li><a class="el" href="index.html#transformcomponent">TransformComponent</a></li>
<li><a class="el" href="index.html#spriterenderer">SpriteRenderer</a></li>
<li><a class="el" href="index.html#renderercomponent">RendererComponent</a></li>
<li><a class="el" href="index.html#progressbar">ProgressBar</a></li>
<li><a class="el" href="index.html#circlecollider">CircleCollider</a></li>
<li><a class="el" href="index.html#resource-management">Resource Management</a></li>
</ul>
</li>
<li><a class="el" href="index.html#conclusion">Conclusion</a></li>
<li><a class="el" href="index.html#acknowledgement">Acknowledgements</a></li>
</ol>
<hr  />
<p><br  />
</p>
<h1><a class="anchor" id="introduction"></a>
Introduction</h1>
<p>Introducing the Fumo Engine â€“ a practical toolkit tailored for indie game developers. With a focus on simplicity and functionality, it offers essential tools for your game development needs. Whether you're an experienced developer or new to the scene, the Fumo Engine provides a solid foundation for crafting 2D games with features like colliders and user interfaces. Streamline your development process and bring your game ideas to life with the Fumo Engine.</p>
<hr  />
<p><br  />
</p>
<h1><a class="anchor" id="creating-scenes"></a>
Creating Scenes</h1>
<p>Every game needs a scene. They represent different levels, menus, or gameplay segments. Here's how you can create your own scene in Fumo Engine:</p>
<ol type="1">
<li>Define your own New Scene Class</li>
<li>Add the Scene to the Scene State Machine</li>
<li>Implement Scene-Specific Logic</li>
<li>Transitions Between Scenes <br  />
</li>
</ol>
<ol type="1">
<li>To create a new scene, you'll need to define a new class that inherits from the BaseScene class. This class will encapsulate the logic, assets, and elements specific to the scene you're creating. <div class="fragment"><div class="line"><span class="comment">// Example: MyScene.h</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_base_scene_8h.html">BaseScene.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyScene : <span class="keyword">public</span> BaseScene {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyScene() {} <span class="comment">// Constructor</span></div>
<div class="line"> </div>
<div class="line">    std::string getName()<span class="keyword"> const override </span>{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;MyScene&quot;</span>; <span class="comment">// Return the name of the scene</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keywordtype">void</span> initialize()<span class="keyword"> override </span>{</div>
<div class="line">    <span class="comment">// Initialize assets, game objects, and other scene-specific elements here</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">void</span> on_activate()<span class="keyword"> override</span>{</div>
<div class="line">    <span class="comment">// Runs on activate, similar to initialize but comes after it</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">void</span> on_deactivate()<span class="keyword"> override</span>{</div>
<div class="line">    <span class="comment">// Runs on deactivate</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">void</span> on_update(<span class="keywordtype">float</span> deltaTime)<span class="keyword"> override</span>{</div>
<div class="line">    <span class="comment">// Runs logic every frame</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">void</span> on_render()<span class="keyword"> override</span>{</div>
<div class="line">    <span class="comment">// Similar to on_update but is mostly used to define rendering functions</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="a_base_scene_8h_html"><div class="ttname"><a href="_base_scene_8h.html">BaseScene.h</a></div></div>
</div><!-- fragment --> <br  />
</li>
<li>Use the addScene() method from the SceneStateMachine class to add the newly created scene class. This ensures that your scene is properly managed by the engine. <div class="fragment"><div class="line"><span class="comment">// Adding the scene to SceneStateMachine, this should be done in Application.cpp</span></div>
<div class="line">MyScene* myScene = SceneStateMachine::addScene&lt;MyScene&gt;();</div>
</div><!-- fragment --> <br  />
</li>
<li>Inside your scene cpp class, implement the necessary functions such as initialize(), on_activate(), on_deactivate(), on_update(), and on_render(). These functions allow you to define how the scene behaves during different stages of its lifecycle. <div class="fragment"><div class="line"><span class="comment">// MyScene.cpp</span></div>
<div class="line"><span class="keywordtype">void</span> MyScene::initialize() {</div>
<div class="line"><span class="comment">// Initialize assets, game objects, and other scene-specific elements here</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyScene::on_activate() {</div>
<div class="line"><span class="comment">// Activate logic specific to this scene</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> on_deactivate() </div>
<div class="line">{</div>
<div class="line"><span class="comment">// Runs on deactivate</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyScene::on_update() {</div>
<div class="line"><span class="comment">// Runs logic every frame</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyScene::on_render()<span class="keyword"> override</span>{</div>
<div class="line"><span class="comment">// Similar to on_update but is mostly used to define rendering functions</span></div>
<div class="line">}</div>
<div class="line"><span class="comment">// ... Other scene-specific functions</span></div>
</div><!-- fragment --> <br  />
</li>
<li>You can transition between scenes by using the loadScene() method provided by the SceneStateMachine class. This allows you to switch from one scene to another based on specific events or conditions. <div class="fragment"><div class="line"><span class="comment">// Transitioning to MyScene by name (!Note: Name defined in getName(), not the class itself)</span></div>
<div class="line">SceneStateMachine::loadScene(<span class="stringliteral">&quot;MyScene&quot;</span>);</div>
</div><!-- fragment --></li>
</ol>
<hr  />
<p><br  />
</p>
<h1><a class="anchor" id="custom-components"></a>
Custom Components</h1>
<p>Custom components allow you to add unique behaviors and functionality to your game objects.</p>
<ol type="1">
<li>Define a New Component Class: Create a new class that inherits from the BaseComponent class. This will serve as the foundation for your custom component. Make sure to include the necessary headers and forward declarations.</li>
</ol>
<div class="fragment"><div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_base_component_8h.html">BaseComponent.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>CustomComponent : <span class="keyword">public</span> BaseComponent {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">CustomComponent(GameObject* go);</div>
<div class="line">~CustomComponent();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> awake();</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> start();</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> update(<span class="keywordtype">float</span> deltaTime);</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> render();</div>
<div class="line">};</div>
<div class="ttc" id="a_base_component_8h_html"><div class="ttname"><a href="_base_component_8h.html">BaseComponent.h</a></div></div>
</div><!-- fragment --><p> <br  />
</p>
<ol type="1">
<li>Implement Constructor and Destructor: Implement the constructor and destructor for your custom component. Pass the GameObject* parameter to the base constructor. Adding additional parameters in the constructor is also possible.</li>
</ol>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;CustomComponent.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespace_fumo_engine.html">FumoEngine</a> {</div>
<div class="line"> </div>
<div class="line">CustomComponent::CustomComponent(GameObject* go) : BaseComponent(go) {</div>
<div class="line"><span class="comment">// Custom initialization if needed</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">CustomComponent::~CustomComponent() {</div>
<div class="line"><span class="comment">// Custom cleanup if needed</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Implement the rest of the component&#39;s methods...</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespace_fumo_engine_html"><div class="ttname"><a href="namespace_fumo_engine.html">FumoEngine</a></div><div class="ttdef"><b>Definition</b> Application.cpp:8</div></div>
</div><!-- fragment --><p> <br  />
</p>
<ol type="1">
<li>Define Custom Behavior: Inside your custom component class, implement the methods (awake(), start(), update(), render(), etc.) to define the behavior of your component. Customize these methods according to the functionality your component should provide.</li>
</ol>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> CustomComponent::awake() {</div>
<div class="line"><span class="comment">// Initialize resources or perform actions upon awakening</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> CustomComponent::start() {</div>
<div class="line"><span class="comment">// Perform setup or initialization tasks when the component starts</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> CustomComponent::update(<span class="keywordtype">float</span> deltaTime) {</div>
<div class="line"><span class="comment">// Implement component-specific update logic</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> CustomComponent::render() {</div>
<div class="line"><span class="comment">// Implement rendering logic if necessary</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> <br  />
</p>
<ol type="1">
<li>Add Custom Component to GameObject: When creating a GameObject, you can attach your custom component to it. For example, if you want to add CustomComponent to a GameObject named myObject:</li>
</ol>
<div class="fragment"><div class="line"><span class="comment">// Create a GameObject</span></div>
<div class="line">GameObject* myObject = <span class="keyword">new</span> GameObject();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Attach CustomComponent to the GameObject</span></div>
<div class="line">myObject-&gt;addComponent&lt;CustomComponent&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Optionally, add more components if needed</span></div>
<div class="line"><span class="comment">// myObject-&gt;addComponent(...);</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add the GameObject to the scene or perform other actions</span></div>
</div><!-- fragment --><p> <br  />
</p>
<ol type="1">
<li>Integrate Custom Component in the Game: After attaching your custom component to a GameObject, integrate it into your game logic. You can manipulate and interact with the component through the GameObject it's attached to. <br  />
</li>
</ol>
<h2><a class="anchor" id="autotoc_md4"></a>
Notes:</h2>
<ul>
<li>Components can be added multiple times to the same game object by default, to disable this funcitonality, you can add the line 'allowMultiple = false' in either your header file or initialize(). It is a variable inherited from BaseComponent.</li>
<li>You can also inherit from your CustomComponent to create your own components with similar behaviours to its parent as seen in showcase sample game's EnemyCollider which inherits the core component of CircleCollider of Fumo Engine.</li>
</ul>
<hr  />
<p><br  />
</p>
<h1><a class="anchor" id="tyingit"></a>
Tying scene and components</h1>
<p>You can tie both together by mostly: </p><pre class="fragment">1. Create and design multiple scenes to represent different parts of your game.
2. Populate scenes with game objects and customize their properties using their built-in functions.
3. Attach and override appropriate components to game objects to give them behaviors.
4. Add logic in the scene itself to manage the interactions and inputs of the scene.
</pre> <hr  />
<p><br  />
</p>
<h1><a class="anchor" id="core-game-engine-components"></a>
Core Game Engine Components</h1>
<h2><a class="anchor" id="transformcomponent"></a>
TransformComponent</h2>
<p>The Transform Component, an essential part of the OCM system, handles transformations within the game. Key features of the Transform Component include:</p>
<ol type="1">
<li>Position Adjustments: Use the provided accessor methods to retrieve and modify the current position values of the GameObject. <div class="fragment"><div class="line"><span class="keywordtype">void</span> setXPosition(<span class="keywordtype">float</span> value);</div>
<div class="line"><span class="keywordtype">void</span> setYPosition(<span class="keywordtype">float</span> value);</div>
<div class="line"><span class="keywordtype">void</span> setPosition(<span class="keywordtype">float</span> x, <span class="keywordtype">float</span> y);</div>
<div class="line"><span class="keywordtype">void</span> setPosition(<a class="code hl_struct" href="struct_vector2.html">Vector2</a> value);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">float</span> getXPosition() <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">float</span> getYPosition() <span class="keyword">const</span>;</div>
<div class="line"><a class="code hl_struct" href="struct_vector2.html">Vector2</a> getPosition() <span class="keyword">const</span>;</div>
<div class="ttc" id="astruct_vector2_html"><div class="ttname"><a href="struct_vector2.html">Vector2</a></div><div class="ttdef"><b>Definition</b> vector.h:16</div></div>
</div><!-- fragment --> <br  />
</li>
<li>Scale Adjustments: Use the provided accessor methods to retrieve and modify the current scale values of the GameObject. <div class="fragment"><div class="line"><span class="keywordtype">void</span> setXScale(<span class="keywordtype">float</span> value);</div>
<div class="line"><span class="keywordtype">void</span> setYScale(<span class="keywordtype">float</span> value);</div>
<div class="line"><span class="keywordtype">void</span> setScale(<span class="keywordtype">float</span> x, <span class="keywordtype">float</span> y);</div>
<div class="line"><span class="keywordtype">void</span> setScale(<a class="code hl_struct" href="struct_vector2.html">Vector2</a> value);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">float</span> getXScale() <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">float</span> getYScale() <span class="keyword">const</span>;</div>
<div class="line"><a class="code hl_struct" href="struct_vector2.html">Vector2</a> getScale() <span class="keyword">const</span>;</div>
</div><!-- fragment --> <br  />
</li>
<li>Rotation Adjustments: Use the provided accessor methods to retrieve and modify the current rotation values of the GameObject. <div class="fragment"><div class="line"><span class="keywordtype">void</span> setRotation(<span class="keywordtype">float</span> value);</div>
<div class="line"><span class="keywordtype">float</span> getRotation() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> setVelocity(<a class="code hl_struct" href="struct_vector2.html">Vector2</a> value);</div>
<div class="line"><a class="code hl_struct" href="struct_vector2.html">Vector2</a> getVelocity() <span class="keyword">const</span>;</div>
</div><!-- fragment --></li>
</ol>
<p><br  />
</p>
<ol type="1">
<li>Velocity Adjustments: Use the provided accessor methods to retrieve and modify the current velocity values of the GameObject. Velocity is an alternate way of setting constant movement for a game object. without having to run it inside the scene's update. This is done by just setting velocity and transform component itself will keep the object movement indefinitely. <div class="fragment"><div class="line"><span class="keywordtype">void</span> setVelocity(<a class="code hl_struct" href="struct_vector2.html">Vector2</a> value);</div>
<div class="line"><a class="code hl_struct" href="struct_vector2.html">Vector2</a> getVelocity() <span class="keyword">const</span>;</div>
</div><!-- fragment --> <br  />
</li>
</ol>
<h2><a class="anchor" id="spriterenderer"></a>
SpriteRenderer</h2>
<p>The SpriteRenderer component provides the following features: Utilizes transform values from the Transform component.</p>
<ol type="1">
<li>Color tinting and opacity control. The default is white color with opacity of 1.0. <div class="fragment"><div class="line"><span class="keywordtype">void</span> setColor(<span class="keywordtype">float</span> r, <span class="keywordtype">float</span> g, <span class="keywordtype">float</span> b);</div>
<div class="line"><span class="keywordtype">void</span> setColor(<a class="code hl_struct" href="struct_vector3.html">Vector3</a> color);</div>
<div class="line"><a class="code hl_struct" href="struct_vector3.html">Vector3</a> getColor();</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> setOpacity(<span class="keywordtype">float</span> a);</div>
<div class="line"><span class="keywordtype">float</span> getOpacity();</div>
<div class="ttc" id="astruct_vector3_html"><div class="ttname"><a href="struct_vector3.html">Vector3</a></div><div class="ttdef"><b>Definition</b> vector.h:36</div></div>
</div><!-- fragment --> <br  />
</li>
<li>Custom sprite size setting. The default is the loaded texture size. <div class="fragment"><div class="line"><span class="keywordtype">void</span> setSize(<span class="keywordtype">float</span> w, <span class="keywordtype">float</span> h);</div>
<div class="line"><span class="keywordtype">void</span> setSize(<a class="code hl_struct" href="struct_vector2.html">Vector2</a> size);</div>
<div class="line"><a class="code hl_struct" href="struct_vector2.html">Vector2</a> getSize();</div>
</div><!-- fragment --> <br  />
</li>
<li>Sprite pivot adjustment. The default is (x:0.5, y:0.5). <div class="fragment"><div class="line"><span class="keywordtype">void</span> setPivot(<span class="keywordtype">float</span> x, <span class="keywordtype">float</span> y);</div>
<div class="line"><span class="keywordtype">void</span> setPivot(<a class="code hl_struct" href="struct_vector2.html">Vector2</a> pivot);</div>
<div class="line"><a class="code hl_struct" href="struct_vector2.html">Vector2</a> getPivot();</div>
</div><!-- fragment --> <br  />
</li>
</ol>
<h2><a class="anchor" id="renderercomponent"></a>
RendererComponent</h2>
<p>The renderer component is a simple component meant to render primitive shapes like Quad, Triangle and Circle. Despite its name, it is not the parent class of SpriteRenderer.</p>
<ol type="1">
<li>Color change and retrieval. <div class="fragment"><div class="line"><span class="keywordtype">void</span> setRGB(<span class="keywordtype">float</span> r, <span class="keywordtype">float</span> g, <span class="keywordtype">float</span> b);</div>
<div class="line"><a class="code hl_struct" href="struct_vector3.html">Vector3</a> getRGB();</div>
</div><!-- fragment --> <br  />
</li>
<li>Set values when drawing a circle (Quad and Triangle doesn't have such settings due to not much need for it, they will use default values)<ul>
<li><code>circlePartition</code> : The amount of triangles needed to render the circle, 5 by default.</li>
<li><code>circleRadius</code> : Radius of the circle, 5.0f by default. <div class="fragment"><div class="line"><span class="keywordtype">void</span> setCircleDrawValues(<span class="keywordtype">int</span> circlePartition, <span class="keywordtype">float</span> circleRadius);</div>
</div><!-- fragment --> <br  />
</li>
</ul>
</li>
<li>Choose the shape to be rendered.<ul>
<li><code>ShapeToDraw</code> : Is an enum containing Quad, Triangle and Circle. <div class="fragment"><div class="line"><span class="keyword">enum</span> ShapeToDraw</div>
<div class="line">{</div>
<div class="line">    Quad,</div>
<div class="line">    Triangle,</div>
<div class="line">    Circle</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> setShapeToDraw(ShapeToDraw value);</div>
</div><!-- fragment --> <br  />
</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="progressbar"></a>
ProgressBar</h2>
<p>The ProgressBarComponent class offers functionality for creating and managing progress bars within the Fumo Engine environment: Uses OpenGL to draw two quads: one for the background of the progress bar and another to indicate the current progress level. The position, size, and color of these rectangles are determined by the progress, barLength, and barHeight values, respectively.</p>
<ol type="1">
<li>Set colors with transparency for both the background and inner(progress) bar. <div class="fragment"><div class="line"><span class="keywordtype">void</span> setBackDropColor(<span class="keywordtype">float</span> r, <span class="keywordtype">float</span> g, <span class="keywordtype">float</span> b, <span class="keywordtype">float</span> a);</div>
<div class="line"><a class="code hl_struct" href="struct_vector4.html">Vector4</a> getBackDropColor();</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> setBarColor(<span class="keywordtype">float</span> r, <span class="keywordtype">float</span> g, <span class="keywordtype">float</span> b, <span class="keywordtype">float</span> a);</div>
<div class="line"><a class="code hl_struct" href="struct_vector4.html">Vector4</a> getBarColor();</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> setBothBarOpacity(<span class="keywordtype">float</span> a);</div>
<div class="ttc" id="astruct_vector4_html"><div class="ttname"><a href="struct_vector4.html">Vector4</a></div><div class="ttdef"><b>Definition</b> vector.h:75</div></div>
</div><!-- fragment --> <br  />
</li>
<li>Sets and gets the value of the progress bar. The default value is set to 0.5f, which is half full. <div class="fragment"><div class="line"><span class="keywordtype">void</span> setProgress(<span class="keywordtype">float</span> value);</div>
<div class="line"><span class="keywordtype">float</span> getProgress();</div>
</div><!-- fragment --> <br  />
</li>
<li>Set pivot for the bar similar to SpriteRenderer <div class="fragment"><div class="line"><span class="keywordtype">void</span> setPivot(<span class="keywordtype">float</span> x, <span class="keywordtype">float</span> y);</div>
</div><!-- fragment --> <br  />
</li>
<li>Set where the progress bar would extrude from, default is Left. This allows easy adaptation to both horizontal and vertical bars. <div class="fragment"><div class="line"><span class="keyword">enum</span> BarPivot</div>
<div class="line">{</div>
<div class="line">    Top,</div>
<div class="line">    Bottom,</div>
<div class="line">    Left,</div>
<div class="line">    Right,</div>
<div class="line">    CenterHorizontal,</div>
<div class="line">    CenterVertical</div>
<div class="line">};</div>
<div class="line"><span class="keywordtype">void</span> setBarExtrudeFrom(BarPivot value);</div>
</div><!-- fragment --> <br  />
</li>
<li>Sets and gets the length of height of the entire bar itself (Both progress bar and backdrop). <div class="fragment"><div class="line"><span class="keywordtype">void</span> setBarLength(<span class="keywordtype">float</span> value);</div>
<div class="line"><span class="keywordtype">float</span> getBarLength();</div>
<div class="line"><span class="keywordtype">void</span> setBarHeight(<span class="keywordtype">float</span> value);</div>
<div class="line"><span class="keywordtype">float</span> getBarHeight();</div>
</div><!-- fragment --> <br  />
</li>
</ol>
<h2><a class="anchor" id="circlecollider"></a>
CircleCollider</h2>
<p>The circle collider is a component that handles collision between different game objects with CircleCollider attached, it is a trigger collider as it does not contain physics or solid collision. The collider also checks for UserTags to determine what object can be collided with, all GameObjects are given <code>Default</code> tag at start.</p>
<ol type="1">
<li>Setting and getting the radius of the circle collider. <div class="fragment"><div class="line"><span class="keywordtype">void</span> setRadius(<span class="keywordtype">float</span> rad);</div>
<div class="line"><span class="keywordtype">float</span> getRadius() <span class="keyword">const</span>;</div>
</div><!-- fragment --> <br  />
</li>
<li>Add, remove and get collidable UserTags. Each game object can only have one UserTag, you can however set the types of tags the collider can collide with. <div class="fragment"><div class="line"><span class="comment">//Defined in UserTags.h, can be added with more tags</span></div>
<div class="line"><span class="keyword">enum</span> UserTag {</div>
<div class="line">    Default,</div>
<div class="line">    Player,</div>
<div class="line">    Enemy,</div>
<div class="line">    Bullet</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> addCollidableTag(UserTag typeName);</div>
<div class="line"><span class="keywordtype">void</span> removeCollidableTag(UserTag typeName);</div>
<div class="line">std::unordered_set&lt;UserTag&gt; getCollidableTags();</div>
</div><!-- fragment --> <br  />
</li>
<li>Manually check collision. This is already used to check collision by the circle collider itself, so there's no need to use this function unless you are specifically checking for collision with a specific object.<ul>
<li><code>containsPoint</code> : Check if a point is within the current circle collider.</li>
<li><code>checkCircleCollision</code> : Check if the current collider is colliding with another specified collider <div class="fragment"><div class="line"><span class="keywordtype">bool</span> containsPoint(<span class="keyword">const</span> <a class="code hl_struct" href="struct_vector2.html">Vector2</a>&amp; point) <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">bool</span> checkCircleCollision(<span class="keyword">const</span> CircleCollider&amp; other);</div>
</div><!-- fragment --> <br  />
</li>
</ul>
</li>
<li>Overridable functions to implement custom logic when during, enter and exit collision.<ul>
<li>These functions are meant to be overrided to provide your custom functionality, example can be seen in the sample game with EnemyCollider class in <a class="el" href="_show_case_scene_8cpp.html">ShowCaseScene.cpp</a>. <div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> OnCollisionEnter(GameObject&amp; other);</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> OnCollisionExit(GameObject&amp; other);</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> OnCollisionStay(GameObject&amp; other);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">//You can inherit the class and override the three specified functions like this</span></div>
<div class="line"><span class="keyword">class </span>CustomCollider : <span class="keyword">public</span> <a class="code hl_class" href="class_fumo_engine_1_1_circle_collider.html">Fumo::CircleCollider</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    CustomCollider(<a class="code hl_class" href="class_fumo_engine_1_1_game_object.html">Fumo::GameObject</a>* go, <span class="keywordtype">float</span> rad = 30.0f, <span class="keywordtype">bool</span> isVisible = <span class="keyword">false</span>) : CircleCollider(go, rad, isVisible) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="class_fumo_engine_1_1_circle_collider.html#ab9a05d5d88a4371fc73749b0f06e3822">OnCollisionEnter</a>(<a class="code hl_class" href="class_fumo_engine_1_1_game_object.html">Fumo::GameObject</a>&amp; other)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">//Your custom logic</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="class_fumo_engine_1_1_circle_collider.html#aff576e9eec4d72bd6fa7d7cac99195f7">OnCollisionStay</a>(<a class="code hl_class" href="class_fumo_engine_1_1_game_object.html">Fumo::GameObject</a>&amp; other)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">//Your custom logic</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="class_fumo_engine_1_1_circle_collider.html#aec43ec3106214f9ad9e5ffc8fe17c4c2">OnCollisionExit</a>(<a class="code hl_class" href="class_fumo_engine_1_1_game_object.html">Fumo::GameObject</a>&amp; other)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">//Your custom logic</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="aclass_fumo_engine_1_1_circle_collider_html"><div class="ttname"><a href="class_fumo_engine_1_1_circle_collider.html">FumoEngine::CircleCollider</a></div><div class="ttdoc">Simple circular trigger collider that fires OnCollisionEnter(), OnCollisionStay(),...</div><div class="ttdef"><b>Definition</b> CircleCollider.h:21</div></div>
<div class="ttc" id="aclass_fumo_engine_1_1_circle_collider_html_ab9a05d5d88a4371fc73749b0f06e3822"><div class="ttname"><a href="class_fumo_engine_1_1_circle_collider.html#ab9a05d5d88a4371fc73749b0f06e3822">FumoEngine::CircleCollider::OnCollisionEnter</a></div><div class="ttdeci">virtual void OnCollisionEnter(GameObject &amp;other)</div><div class="ttdoc">Overridable function similar to Unity OnTriggerEnter(), inherit this function from this class to call...</div><div class="ttdef"><b>Definition</b> CircleCollider.cpp:174</div></div>
<div class="ttc" id="aclass_fumo_engine_1_1_circle_collider_html_aec43ec3106214f9ad9e5ffc8fe17c4c2"><div class="ttname"><a href="class_fumo_engine_1_1_circle_collider.html#aec43ec3106214f9ad9e5ffc8fe17c4c2">FumoEngine::CircleCollider::OnCollisionExit</a></div><div class="ttdeci">virtual void OnCollisionExit(GameObject &amp;other)</div><div class="ttdoc">Overridable function similar to Unity OnTriggerStay(), inherit this function from this class to call ...</div><div class="ttdef"><b>Definition</b> CircleCollider.cpp:176</div></div>
<div class="ttc" id="aclass_fumo_engine_1_1_circle_collider_html_aff576e9eec4d72bd6fa7d7cac99195f7"><div class="ttname"><a href="class_fumo_engine_1_1_circle_collider.html#aff576e9eec4d72bd6fa7d7cac99195f7">FumoEngine::CircleCollider::OnCollisionStay</a></div><div class="ttdeci">virtual void OnCollisionStay(GameObject &amp;other)</div><div class="ttdoc">Overridable function similar to Unity OnTriggerExit(), inherit this function from this class to call ...</div><div class="ttdef"><b>Definition</b> CircleCollider.cpp:178</div></div>
<div class="ttc" id="aclass_fumo_engine_1_1_game_object_html"><div class="ttname"><a href="class_fumo_engine_1_1_game_object.html">FumoEngine::GameObject</a></div><div class="ttdoc">Actors/Objects that can have logic and behaviour to interact with one another in a game scene.</div><div class="ttdef"><b>Definition</b> GameObject.h:21</div></div>
</div><!-- fragment --> <br  />
</li>
</ul>
</li>
<li>Enable and disable collider render for debugging.<ul>
<li>Method 1 : Enable when adding the component (Cannot be disabled during runtime). <div class="fragment"><div class="line"><span class="comment">//Second parameter is to enable the debug</span></div>
<div class="line">yourGameObject-&gt;addComponent&lt;<a class="code hl_class" href="class_fumo_engine_1_1_circle_collider.html">Fumo::CircleCollider</a>&gt;(radiusValue, <span class="keyword">true</span>);</div>
</div><!-- fragment --> <br  />
</li>
<li>Method 2 : Enable globally for all objects (Can be done during runtime). <code>cpp Fumo::CircleCollider::globalShowCollider = true; </code> <br  />
</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="resource-management"></a>
Resource Management</h2>
<p>Resource allocation is managed through the ResourceAllocator class. This allows different kinds of resource allocators to exist without needing explicit code creation. This allows different types of resources and allocated before they are displayed or called within the game screen, the current resource in the engine are textures only but the ResourceAllocator is capable of handling differnt types of resources.</p>
<ol type="1">
<li>Requesting Resource: To request a texture, call the <code>ResourceAllocator::allocateResource&lt;Your_Resource_type&gt;(path_string)</code>, this would return the specified resource instance of the given type.</li>
<li>Releasing Resource: When a texture is no longer needed, call <code>ResourceAllocator::releaseResource&lt;Your_Resource_type&gt;(path_string)</code>, this would do a check if said resource is shared amongst other game objects currently, if not it will unload the resource, if it is it would just reduce it's reference count.</li>
<li>Reference Counting: Each resource class maintains a reference count. Every time a resource is requested or reused, its reference count increases. When a resource is deleted, its reference count decreases. Resource with a reference count of zero are safe to be deleted.</li>
<li>Resource Management: The ResourceAllocator maintains an internal map of void pointers (void*) that stores loaded resource. This map allows for quick retrieval of existing resources and efficient management of memory.</li>
</ol>
<hr  />
<p><br  />
</p>
<h1><a class="anchor" id="conclusion"></a>
Conclusion</h1>
<p>Thank you for attempting to use Fumo Engine! If you have any questions or issues do let me know on github or discord. Stay Funky.</p>
<h1><a class="anchor" id="acknowledgement"></a>
Acknowledgements</h1>
<p>External libraries used:</p><ul>
<li>glad by OpenGL</li>
<li>glfw by OpenGL</li>
<li><a class="el" href="texture__utils_8h.html">texture_utils.h</a> provided by Mr. Faris</li>
<li>angle_utils/vector provided by Mr. Faris</li>
<li>angle_utils/matrix provided by Mr. Faris</li>
<li>Doxygen for generating this document</li>
</ul>
<p>Images:</p><ul>
<li>Fumo from Touhou Project</li>
<li>Every other art asset is self-made </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
